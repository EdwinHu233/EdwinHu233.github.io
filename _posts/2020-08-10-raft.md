---
layout: post
title: "论文笔记：Raft"
---

## Replicated State Machine

Replicated state machine 指的是，
在多个服务器上分别运行一套相同的 state machine，
对于相同的输入，应该产生相同的输出。
通过这种冗余设计来确保分布式系统的容错性。

一般来说，replicated state machine 是通过 replicated log 实现的。
通过 consensus algorithm 保证各个服务器上 log 的一致性，
然后 state machine 从 log 中按顺序取出指令，依次执行。

在[这篇论文](/asset/raft/raft-extended.pdf)中提出的 Raft，就是一个用于保证 log 一致性的 consensus algorithm。

## The Raft Consensus Algorithm

### Basics

Raft 算法可以划分为几个相对对立的部分：
leader election, log replication, safety 和 membership changes，
在接下来几个小节依次讲解。

一个 Raft 集群包含多台服务器（例如，5 台），每个服务器的身份可能是 leader/candidate/follower 中的一种。
正常情况下，集群中恰有一个 leader ，其余都是 follower 。
而在 leader election 时，会发生 follower -> candidate 和 candidate -> leader/follower 的转变。

Raft 算法中，时间被划分为若干个不定长的 term （任期？），每个 term 由一个单调递增的整数标识。
在一个 term 的最开始，会进行 leader election 。
如果成功选举出一个 leader ，则这个 term 正常持续；
否则这个 term 会结束，开始新的 term 。
如下图所示：

![leader election](/asset/raft/leader-election.png)

每个服务器会保存一个数字 `currentTerm` ，表示自认为所在的 term 。
这个数字会在通讯时彼此交换，如果一个服务器发现自己的 `currentTerm` 比通讯对方的小，就说明自己的 `currentTerm` 过时。

- 任何服务器发现自己的 `currentTerm` 过时，都要更新自己的 `currentTerm`
- candidate/leader 如果发现自己的 `currentTerm` 过时，就会回退到 follower 状态。
- 任何服务器发现对方的 `currentTerm` 过时，都会拒绝对方的 request

Raft 的核心机制由两个 RPC 实现：

- `RequestVote`: 在选举时由 candidate 发起
- `AppendEntries`: 由 leader 发起，用于 log replication ，并作为 heartbeat

服务器会尽量并行地发送 RPC ，如果有的 RPC 没有 response ，则会重新发送。

### Leader Election

服务器启动时，身份为 follower 。
如果 follower 不断收到来自 leader/candidate 的 RPC ，那么就会始终保持在 follower 状态。
同时，leader 也会向 follower 们发送“空的”（不附加任何 log entry） 的 `AppendEntries` 作为 heartbeat ，确保自身地位。

如果一个 follower 在一定时间（称为 election timeout ）之内没有收到 RPC 的话，就认为 leader 出现问题。
此时，follower 会将自己的 `currentTerm` 加1，并转变为 candidate 状态。
之后，这个服务器会给自己投一票，并向其他服务器发起 `RequestVote` 。
一个服务器在一个 term 内，只能给最多一个服务器投票（原则上是给第一个向自己请求的服务器投票，但 [Safety](#Safety) 一节中会引入限制条件）

Leader election 的过程中，candidate 可能会收到自称 leader 的服务器发来的 `AppendEntries` 。
这时 candidate 会根据 `currentTerm` 采取不同行动：
- 如果自己的 `currentTerm` > 对方的 `currentTerm` ，则认为对方是过气 leader ，从而拒绝对方的 RPC 请求
- 否则，认为对方是当前合法的 leader ，从而回退到 follower 状态

在一个 candidate 进行 leader election 时，会发生以下三种情况：
- 自己当选
- 其他 candidate 当选
- 没有任何 candidate 当选（有多个 candidate 获得了相同的最高投票数）。
具体来说，在 leader election 刚开始时，candidate 会重启 election timeout ，如果直到超时也没有任何 candidate 当选，
就会结束当前 term ，并开始新 term ，重新选举。

可以发现，election timeout 是一个很关键的因素。Follower 转变为 candidate 会用到这个值，candidate 重新发起选举也会用到这个值。
为了降低第三种情况的影响，在 Raft 算法的设计中，要求每个服务器的 election timeout 都是在某个区间内随机采样的。
因此，大部分情况下只会有一个 follower 发生超时并转变为 candidate ；
即使有多个 candidate 同时存在，也会在不同时间发生第二次超时，错开重新选举的时间。

### Log Replication

### Safety

### Follower and Candidate Crashes

### Timing and Availability
